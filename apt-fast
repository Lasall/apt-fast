#!/bin/bash
#
# apt-fast v1.7
# Use this just like aptitude or apt-get for faster package downloading.
#
# Copyright: 2008-2012 Matt Parnell, http://www.mattparnell.com
# Improvements, maintenance, revisions - 2012 Dominique Lasserre
#
# You may distribute this file under the terms of the GNU General
# Public License as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later version.
#
[ -n "$DEBUG" ] && set -xv

# Print colored messages.
# Usage: msg "message text" "message type" "optional: err"
# Message types are 'normal', 'hint' or 'warning'. Warnings and messages with a
# third argument are piped to stderr.
msg(){
  case "$2" in
    normal) beginColor="$cGreen";;
    hint) beginColor="$cBlue";;
    warning) beginColor="$cRed";;
  esac

  if [ -z "$3" ] && [ "$2" != "warning" ]; then
    echo -e "${aptfast_prefix} ${beginColor}$1${endColor}";
  else
    echo -e "${aptfast_prefix} ${beginColor}$1${endColor}"; >&2
  fi
}

# Search for known options and decide if root privileges are needed.
root=1  # default value: we need root privileges
option=
for arguments in $@; do
  if [ "$arguments" == "upgrade" ] ||
      [ "$arguments" == "install" ] ||
      [ "$arguments" == "dist-upgrade" ] ||
      [ "$arguments" == "build-dep" ]; then
    option="install"
    break
  elif [ "$arguments" == "update" ]; then
    option="update"
    break
  elif [ "$arguments" == "clean" ] ||
      [ "$arguments" == "autoclean" ]; then
    option="clean"
    break
  elif [ "$arguments" == "download" ]; then
    option="download"
    root=0
    break
  elif [ "$arguments" == "source" ]; then
    option="source"
    root=0
    break
  elif [ "$arguments" == "changelog" ]; then
    root=0
    break
  fi
done

# Check for proper privileges.
# Call explicitly with environment variables to get them into root conext.
#FIXME: Variables passed by command line should overwrite
#       config file variables.
if ((root)); then
  [ "$UID" = 0 ] || exec sudo LCK_FILE="$LCK_FILE" \
                              DOWNLOADBEFORE="$DOWNLOADBEFORE" \
                              _APTMGR="$_APTMGR" \
                              APTCACHE="$APTCACHE" \
                              DLDIR="$DLDIR" \
                              DLLIST="$DLLIST" \
                              LISTDIR="$LISTDIR" \
                              _MAXIMUM="$MAXIMUM" \
                              aptfast_prefix="$aptfast_prefix" \
                              LEGACY="$LEGACY" "$0" "$@"
fi

# Set variable only if not already set.
#NOTE: Disadvantage of this function is: Quoted variables are not longer
#      quoted when passed to function (see color variables). Therefore we
#      quote values explicitly.
setvar(){
  [ "$(eval echo \$${1%%=*})" ] || eval "${1%%=*}=\"${1#*=}\""
}

# Define lockfile.
# Use /tmp as directory because everybody (not only root) has to have write
# permissions.
# We need lock for non-root commands too, because we only have one download
# list file.
setvar LCK_FILE="/tmp/apt-fast"

# Set default package manager, APT cache, temporary download dir,
# temporary download list file, and maximal parallel downloads
setvar _APTMGR=apt-get
eval $(apt-config shell rootdir Dir)
eval $(apt-config shell cachedir Dir::Cache)
eval $(apt-config shell archivesdir Dir::Cache::archives)
eval $(apt-config shell statedir Dir::State)
eval $(apt-config shell listsdir Dir::State::lists)
setvar APTCACHE="${rootdir}${cachedir}${archivesdir}"
setvar DLDIR="$APTCACHE/apt-fast"
setvar DLLIST="/tmp/apt-fast.list"
setvar LISTDIR="${rootdir}${statedir}${listsdir}"
setvar _MAXNUM=5

# Prefix in front of apt-fast output:
setvar aptfast_prefix=


# Set color variables.
setvar cGreen='\e[0;32m'
setvar cRed='\e[0;31m'
setvar cBlue='\e[0;34m'
setvar endColor='\e[0m'

# Load config file.
setvar CONFFILE="/etc/apt-fast.conf"
source "$CONFFILE"

# Disable colors if not executed in terminal.
if [ ! -t 1 ]; then
  cGreen=
  cRed=
  cBlue=
  endColor=
  #FIXME: Time not updated.
  [ -z "$aptfast_prefix" ] && aptfast_prefix="[apt-fast $(date +"%T")]"
fi


# Check if a lock file exists.
if [ -f "$LCK_FILE.lock" ]; then
  msg "apt-fast already running!" "warning"
  msg "Verify that all apt-fast processes are finished then remove $LCK_FILE.lock and try again." "hint"
  exit 1
fi

# Remove lock file.
LCK_RM() {
  # Remove URI file to prevent write permissions issues in /tmp directory.
  #[ -f "$DLLIST" ] && rm -f "$DLLIST"
  if [ -n "$LOCKPID" ]; then
    kill "$LOCKPID" && lockfile-remove "$LCK_FILE"
  fi
}

# Remove lock file and exit with code 1.
LCK_RM_1() {
  LCK_RM
  exit 1
}

trap "LCK_RM_1" 2 9 15

# Get the package URLs.
get_uris(){
  #NOTE: aptitude doesn't have this functionality, so we use apt-get to get
  #      package URIs.
  apt-get -y --print-uris $@ | egrep -o -e "(ht|f)tp://[^\']+" > "$DLLIST"
}

# Move file to parent directory.
move_plain(){
  mv -- "$2" "../${2#./$1*}"
}
export -f move_plain

# Helper function if update files are missing.
warn_missing_files(){
  # Drop missing translation files silently.
  if echo "$1" | grep -qv "/Translation" 2>/dev/null; then
    msg "W: File not found on local file system:" "warning"
    msg "$1" "warning"
  fi
}

# Copy, verify and extract local files for update command.
local_update(){
  local IFS=" "
  # Copy files from local repositories.
  # We have to try different compression types because apt-get --print-uri will
  # only list .bz2 compression uris.
  msg "\n Setup local files" "normal"
  for uri in "${localfiles[@]}"; do
    # Split URI and file name.
    local fcp=( $uri )
    if echo "${fcp[0]}" | grep -qv 'Release$'; then
      # .bz2 or no compression
      if [ -f "${fcp[0]}" ]; then
        cp "${fcp[0]}" "APTFAST${fcp[1]}"

      # .gz
      elif [ -f "${fcp[0]%.*}.gz" ]; then
        cp "${fcp[0]%.*}.gz" "APTFAST${fcp[1]}".gz

      # stripped file extension / no compression
      elif [ -f "${fcp[0]%.*}" ]; then
        cp "${fcp[0]%.*}" "APTFAST${fcp[1]}"

      else
        #TODO: Add all missing files to array and display them not till
        #      the end.
        warn_missing_files "${fcp[0]}"
      fi

    elif [ -f "${fcp[0]%/*}/InRelease" ]; then
      cp "${fcp[0]%/*}/InRelease" "APTFAST${fcp[1]%_*}_InRelease"
      if [ -f "${fcp[0]%/*}/Release.gpg" ]; then
        cp "${fcp[0]%/*}/Release.gpg" "APTFAST${fcp[1]%_*}_Release.gpg"
      else
        warn_missing_files "${fcp[0]%/*}/Release.gpg"
      fi

    elif [ -f "${fcp[0]%/*}/Release" ]; then
      cp "${fcp[0]%/*}/Release" "APTFAST${fcp[1]%_*}_Release"

    else
      #TODO: See above.
      warn_missing_files "${fcp[0]}"
    fi
  # Fork to background to enable parallel download.
  done &
  local WAITPID_LOC=$!
  wait $WAITPID_LOC

  # Verify signatures.
  #TODO: Be more quiet.
  msg "\n Verify local signatures..." "normal"
  for file in APTFAST_*_InRelease; do
    [ -f "$file" ] || continue
    gpgv ${keyrings[@]} $file
  done &
  local WAITPID_REL=$!

  # Verify checksums in Release file.
  #TODO

  # Unpack index archives and copy them to lists directory.
  msg "\n Unpack local archives..." "normal"
  for file in APTFAST_*.bz2; do
    [ -f "$file" ] || continue
    local tmpname="${file%*.bz2}"
    echo $tmpname
    bunzip2 -cf "$file" > "../${tmpname#APTFAST*}" && rm -f -- "$file"
  done &
  local WAITPID_BZ2=$!

  for file in APTFAST_*.gz; do
    [ -f "$file" ] || continue
    local tmpname="${file%*.gz}"
    gunzip -cnf "$file" > "../${tmpname#APTFAST*}" && rm -f -- "$file"
  done &
  local WAITPID_GZ=$!

  wait $WAITPID_REL
  msg "\n Install local remaining files..." "normal"
  find -maxdepth 1 -type f \
    -regex '^./APTFAST_.+\(Release\.gpg\|InRelease\|Release\|Packages\|Sources\)$' \
    -execdir bash -c 'move_plain "APTFAST" "{}"' \; &
  local WAITPID_PLAIN=$!

  wait $WAITPID_BZ2
  wait $WAITPID_GZ
  wait $WAITPID_PLAIN
  msg "\n Local files up to date." "normal"
}

# Download, verify and extract external files for update command.
external_update(){
  local IFS=" "
  # Setup aria2c download list and download files.
  msg "\n Setup external files..." "normal"
  [ -f "$DLLIST" ] && rm -f -- "$DLLIST"
  for uri in "${exturis[@]}"; do
    local fcp=( $uri )
    if echo "${fcp[0]}" | grep -qv 'Release$'; then
      # Instead of checking avaibility of files we let aria decide by passing
      # alternatives.
      # Here we hope that aria will do not mess up with different compression
      # types if those (.bz2, .gz and plain) exist.
      # If you read this comment and do not encounter errors, take a few
      # minutes and thank aria for that great feature.
      # At this point we don't know the filetype so we set EX element to
      # file name (same with Release file because we don't know if sigend
      # or unsigned Release file was downloaded).
      echo -e "${fcp[0]%.*}.bz2\t${fcp[0]%.*}.gz\t${fcp[0]%.*}\n out=APTFAST-EX${fcp[1]}" >> "$DLLIST"

    else
      echo -e "${fcp[0]%/*}/InRelease\t${fcp[0]%/*}/Release\n out=APTFAST-EX${fcp[1]%_*}_Release" >> "$DLLIST"
      # Try to download .gpg file.
      echo -e "${fcp[0]%/*}/Release.gpg\n out=APTFAST-EX${fcp[1]%_*}_Release.gpg" >> "$DLLIST"
    fi
  done
  eval "${_DOWNLOADER}" &
  local WAITPID_EXT=$!
  wait $WAITPID_EXT

  # Rename file (extensions) according to file type.
  #NOTE: File names are friendly so we can work with shell expansions (which is
  #      faster than find).
  #FIXME: This is a bottle neck.
  msg "\n Setup external file types..." "normal"
  for file in APTFAST-EX*; do
    [ -f "$file" ] || continue
    local ftype="$(file -b "$file")"
    if echo "$ftype" | grep -q '^bzip2'; then
      mv -- "$file" "${file%*.}.bz2"
    elif echo "$ftype" | grep -q '^gzip'; then
      mv -- "$file" "${file%*.}.gz"
    elif echo "$file" | grep -q '_Release$' &&
      grep -qm 1 -- "-----BEGIN PGP SIGNED MESSAGE-----" "$file"; then
      mv -- "$file" "${file%*Release}InRelease"
    fi
  done

  # Verify signatures.
  #TODO: Be more quiet.
  msg "\n Verify external signatures..." "normal"
  for file in APTFAST-EX*_InRelease; do
    [ -f "$file" ] || continue
    gpgv ${keyrings[@]} $file
  done &
  local WAITPID_REL=$!

  # Verify checksums in Release file.
  #TODO

  # Unpack index archives.
  msg "\n Unpack external archives..." "normal"
  for file in APTFAST-EX*.bz2; do
    [ -f "$file" ] || continue
    local tmpname="${file%*.bz2}"
    bunzip2 -cf "$file" > "../${tmpname#APTFAST-EX*}" && rm -f -- "$file"
  done &
  local WAITPID_BZ2=$!

  for file in APTFAST-EX*.gz; do
    [ -f "$file" ] || continue
    local tmpname="${file%*.gz}"
    gunzip -cnf "$file" > "../${tmpname#APTFAST-EX*}" && rm -f -- "$file"
  done &
  local WAITPID_GZ=$!

  wait $WAITPID_REL
  msg "\n Install external remaining files..." "normal"
  find -maxdepth 1 -type f \
    -regex '^./APTFAST-EX.+\(Release\.gpg\|InRelease\|Release\|Packages\|Sources\)$' \
    -execdir bash -c 'move_plain "APTFAST-EX" "{}"' \; &
  local WAITPID_PLAIN=$!

  wait $WAITPID_BZ2
  wait $WAITPID_GZ
  wait $WAITPID_PLAIN
  msg "\n External files up to date." "normal"
}

# Create and insert a PID number to lockfile.
lockfile-create "$LCK_FILE"
lockfile-touch "$LCK_FILE" &
# Declare global variable (to use it in LCK_RM function) and save PID of last
# job running in background (lockfile-touch process):
export LOCKPID="$!"

# Make sure one of the download managers is enabled
if [ -z "$_DOWNLOADER" ]; then
  msg "You must configure $CONFFILE to use axel or aria2c." "normal" "err"
  LCK_RM_1
fi

# Make sure package manager is available.
if [ ! $(command -v "$_APTMGR") ]; then
  msg "\`$_APTMGR\` command not available." "warning"
  msg "You must configure $CONFFILE to use either apt-get or aptitude." "normal" "err"
  LCK_RM_1
fi


# Run actions.
if [ "$option" == "install" ]; then
  msg "\n Working... this may take a while." "normal"

  get_uris $@

  # Check if "assume yes" switch is enabled and if yes enable $DOWNLOADBEFORE.
  #TODO: Get real value over APT items APT::Get::Assume-Yes and
  #      APT::Get::Assume-No .
  #FIXME: Composed short options e.g. "-yV" are not recognised - we should use
  #      getopts for proper option passing.
  for option in $@; do
    if [ "$option" == "-y" ] ||
        [ "$option" == "--yes" ] ||
        [ "$option" == "--assume-yes" ]; then
      DOWNLOADBEFORE=true
    elif [ "$option" == "--assume-no" ]; then
      DOWNLOADBEFORE=
    fi
  done

  # Test /tmp/apt-fast.list file exists AND not zero bytes.
  # Then download all files from the list.
  if [ $(cat "$DLLIST" | wc -l) -gt 0 ] && [ ! "$DOWNLOADBEFORE" ]; then
    cat "$DLLIST"

    echo -ne "${cRed} If you want to download the packages on your system press Y else n to abort. [Y/n]:  ${endColor}"

    while ((!updsys)); do
      read -sn1 -t 20 answer || { msg "\n Timed out." "warning"; LCK_RM_1; }
      case "$answer" in
        [JjYy])    result=1; updsys=1 ;;
        [Nn])      result=0; updsys=1 ;;
        "")        result=1; updsys=1 ;;
        *)         updsys=0 ;;
      esac
    done
  else
    result=1
  fi

  echo

  # Continue if answer was right or DOWNLOADBEFORE is enabled.
  if ((result)); then
    if [ -s "$DLLIST" ]; then
      # Test if apt-fast directory is present where we put packages.
      if [ ! -d "$DLDIR" ]; then
        mkdir -p -- "$DLDIR"
      fi

      cd "$DLDIR" &>/dev/null || LCK_RM_1

      #FIXME: Better handling of finished downloads but canceled apt-fast
      #       axel redownloads deb again (with [0-9] suffix).
      eval "${_DOWNLOADER}" # execute downloadhelper command
      if [ $(find "$DLDIR" -printf . | wc -c) -gt 1 ]; then
        # Move all packages to the apt install directory by force to ensure
        # already existing debs which may be incomplete are replaced
        find -type f -name "*.deb" -execdir mv -ft "$APTCACHE" {} \+
      fi
      cd - &>/dev/null
    fi
  else
    LCK_RM_1
  fi

  #FIXME: quotes get lost: apt-fast install "foo*" -> apt-get install foo*
  "${_APTMGR}" $@ &
  APTPID=$!

elif [ "$option" == "update" ] && [ ! "$LEGACY" ]; then
  [ ! -d "$LISTDIR/partial" ] && mkdir -p -- "$LISTDIR/partial"
  cd -- "$LISTDIR/partial" &>/dev/null || LCK_RM_1

  # Clean up old files to dismiss deprecated package lists.
  #NOTE: If interrupted package cache is garbage (not complete).
  find ../ -maxdepth 1 -type f -delete

  # Copy local files first because aria2c has no support to download local
  # files, see aria issue with id 3094269.

  # It is faster to call apt-get --print-uris twice than save it to array and
  # perform actions with array.
  IFS=$'\n'
  exturis=( $(apt-get -y --print-uris $@ |
    sed -e "/^'file:/d" \
        -e "s/'\(.\+\)'[ \t]\+\([^ \t]\+\).*/\1 \2/") ) || LCK_RM_1
  localfiles=( $(apt-get -y --print-uris $@ |
    sed -n "s/^'file:\(.\+\)'[ \t]\+\([^ \t]\+\).*/\1 \2/p") )

  eval $(apt-config shell etcdir Dir::Etc)
  eval $(apt-config shell keyring Dir::Etc::trusted)
  eval $(apt-config shell keyringdir Dir::Etc::trustedparts)
  keyrings=( "--keyring ${rootdir}${etcdir}${keyring}"
    $(find "${rootdir}${etcdir}${keyringdir}" -maxdepth 1 -type f -name '*.gpg' -printf "--keyring %p\n") )

  local_update &
  WAITPID_LOCUPDATE=$!
  external_update &
  WAITPID_EXTUPDATE=$!
  wait $WAITPID_LOCUPDATE
  wait $WAITPID_EXTUPDATE

  # Cleanup remaining files.
  find -maxdepth 1 -type f -name 'APTFAST*' -delete


elif [ "$option" == "clean" ]; then
  #FIXME: quotes get lost (see above)
  "${_APTMGR}" $@ && {
    find "$DLDIR" -maxdepth 1 -type f -delete
    [ -f "$DLLIST" ] && rm -f -- "$DLLIST"*
  }

elif [ "$option" == "download" ]; then
  #NOTE: axel does not recognize already downloaded packages.
  get_uris $@
  eval "${_DOWNLOADER}"

elif [ "$option" == "source" ]; then
  msg "\n Working... this may take a while.\n" "normal"
  get_uris $@
  eval "${_DOWNLOADER}"
  # We use APT manager here to provide more verbose output. This method is
  # slightly slower then extractiong packages manually after download but also
  # more hardened (e.g. some options like --compile are available).
  "${_APTMGR}" $@ &
  APTPID=$!
  # Uncomment following snippet to extract source directly and comment
  # both lines before.
  #while read srcfile; do
  #  # extract only .dsc files
  #  echo "$srcfile" | grep -q '\.dsc$' || continue
  #  dpkg-source -x "$(basename "$srcfile")"
  #done < "$DLLIST"

# Execute package manager directly if unknown options are passed.
else
  #FIXME: quotes get lost (see above)
  "${_APTMGR}" $@ &
  APTPID=$!

fi


# Wait for APT processes to finish.
[ -n "$APTPID" ] && wait $APTPID

# After error or all done remove our lockfile
LCK_RM
